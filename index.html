<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="custom.css">
  <link rel="stylesheet" href="css/theme/white.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName('head')[0].appendChild(link);
  </script>
</head>
<body>
<div class="reveal">
  <div class="slides">
    <section>
      <h1>Модули в C++20</h1>
      <p>Дмитрий Кожевников</p>
      <img src="./jetbrains_copy.png" class="plain" alt="" width="781" height="247">
    </section>

    <section>
      <h2>Модули в C++20</h2>

      <ul>
        <li>Самая ожидаемая фича</li>
        <li>Самая непонятся фича</li>
        <li>Самая революционная фича</li>
        <li>Не меняет способ написания программ</li>
      </ul>
    </section>

    <section class="center">
      <h1>Зачем нужны модули?</h1>
    </section>

    <section>
      <h2>Существующая модель компиляции</h2>

      <ul>
        <li>Пришла из C</li>
        <li>Использует препроцессор для переиспользования кода</li>
        <li>Препроцессор не знает о семантике языка</li>
      </ul>
    </section>

    <section>
      <h2>Проблема: скорость компиляции</h2>
      <pre><code data-trim lang="c++">
        #include &lt;iostream&gt;
        int main() {
            std::cout << "Hello, world!" << std::endl;
            return 0;
        }
      </code></pre>

      <ul>
        <li>30 тысяч строчек (на моей машине)</li>
        <li>Все 30 тысяч должны быть обработаны компилятором</li>
        <li>Бывает миллион сточек в больших проектах</li>
        <li>Время сборки растет нелинейно с ростом проекта:
          <ul>
            <li>Увеличивается количество TU</li>
            <li>Увеличиваетя размер TU</li>
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>Проблема: протекающие имена</h2>
      <p>Пример кода из реализации stdlib:</p>
      <pre><code data-trim lang="c++">
      template &lt;class _Tp, class _Allocator&gt;
      inline _LIBCPP_INLINE_VISIBILITY void
      vector&lt;_Tp, _Allocator&gt;::push_back(const_reference __x)
      {
          if (this->__end_ != this->__end_cap())
          {
              __RAII_IncreaseAnnotator __annotator(*this);
              __alloc_traits::construct(this->__alloc(),
                                        _VSTD::__to_raw_pointer(this->__end_), __x);
              __annotator.__done();
              ++this->__end_;
          }
          else
              __push_back_slow_path(__x);
      }
      </code></pre>
    </section>

    <section>
      <h2>Проблема: протекающие имена</h2>
      <p>Почему это так ужасно?</p>
      <pre><code data-trim lang="c++">
        //user-header.h
        #define annotator 1
        class RAII_IncreaseAnnotator{};
      </code></pre>
      <pre><code data-trim lang="c++">
        #include "user-header.h"
        #include &lt;vector&gt;
      </code></pre>
    </section>

    <section>
      <h2>Проблема: протекающие имена</h2>
      <ul>
        <li>
          Все имена из ранее включенных хедеров - в зоне видимости
          <ul>
            <li>Макросы</li>
            <li>Классы</li>
            <li>Глобальные переменные</li>
          </ul>
        </li>
        <li>Особенно плохо для авторов библиотек</li>
        <li>Авторы стандартной библиотеки могу использовать зарезерврованные имена</li>
      </ul>
    </section>

    <section>
      <h2>Проблема: нарушение ODR</h2>
      <p>One Definition Rule (упрощенно):</p>
      <ul>
        <li>Только одно определение в TU</li>
        <li>Все определения в "программе" должны быть идентичными</li>
        <li>При нарушении: ill-formed, no diagnostics required</li>
      </ul>
    </section>

    <section>
      <h2>Проблема: нарушение ODR</h2>
      <pre><code data-trim lang="c++">
        // a.cpp
        #include "header.h"
      </code></pre>
      <pre><code data-trim lang="c++">
        // b.cpp
        #define _NDEBUG
        #include "header.h"
      </code></pre>

      <ul>
        <li>Влияет на member layout, размер объектов, типы, ...</li>
        <li>Легко сделать случайн</li>
      </ul>
    </section>

    <section>
      <h2>Проблема: случайные зависимости</h2>
      <pre><code data-trim lang="c++">
        // lib1.h
        struct Lib1Widget{};
      </code></pre>
      <pre><code data-trim lang="c++">
        // lib2.h
        struct Lib2Gadget{
           Lib2Gadget(Lib1Widget const& w);
        };
      </code></pre>
      <pre><code data-trim lang="c++">
        // main.cpp
        #include "lib1.h"
        #include "lib2.h"
      </code></pre>

    </section>

    <section>
      <h2>Модули призваны улучшить:</h2>
      <ul>
        <li>Время сборки</li>
        <li>Изоляцию имен</li>
        <li>Борьбу с ODR</li>
        <li>Отслеживание зависимостей</li>
      </ul>
    </section>

    <section>
      <h2>Модули: Hello, world!</h2>
      <pre><code data-trim lang="c++">
        import std.io;
        int main() {
           std::cout << "Hello, world!" << std::endl;
        }
      </code></pre>
      <ul>
        <li>Модуль std.io module парсится отдельно</li>
        <li>Интерфейс модуля после парсинга хранится в бинарном файле</li>
        <li>Import declarations загружают интерфейс модуля без репарса</li>
      </ul>
    </section>

    <section>
      <h2>Модули: Hello, world!</h2>
      <pre><code data-trim lang="c++">
        import std.io;
        int main() {
           std::cout << "Hello, world!" << std::endl;
        }
      </code></pre>
      <ul>
        <li>Точки в имени модуля ничего не значат</li>
        <li>Модули не связаны с namespaces</li>
        <li>Import declarations должны быть в начале файла</li>
        <li>
          Информация в модуле эквивалентна исходному коду:
          <ul>
            <li>Inline функции</li>
            <li>Шаблоны</li>
            <li>Сообщения об ошибках</li>
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>Информация в модуле эквивалентна исходному коду:</h2>
      <ul>
        <li>Inline функции</li>
        <li>Шаблоны</li>
        <li>Сообщения об ошибках</li>
      </ul>
    </section>

    <section>
      <h2>Библиотека: header-based</h2>
      <pre><code data-trim lang="c++">
        // simple_lib.h
        int foo();
        template&lt;typename T&gt; T bar(T x) {
          return detail::baz(x);
        }

        namespace detail {
          template&lt;typename T&gt; T baz(T x) {
            return x + 1;
          }
        }
      </code></pre>
      <pre><code data-trim lang="c++">
        // simple_lib.cpp
        #include "header.h"
        int foo() {
          return bar(42);
        }
      </code></pre>
    </section>

    <section>
      <h2>Библиотека: на модулях</h2>
      <pre><code data-trim lang="c++">
        // simple_lib.cppm
        export module simple_lib;

        template&lt;typename T&gt;
        export T bar(T x) {
          return baz(x);
        }
        
        template&lt;typename T&gt; T baz(T x) {
          return x + 1;
        }

        export int foo() {
          return bar(42);
        }
      </code></pre>
    </section>

    <section>
      <h2>Module units</h2>
      <p>Module interface unit:</p>
      <pre><code data-trim lang="c++">
        // simple_lib.cppm
        export module simple_lib;

        template&lt;typename T&gt;
        export T bar(T x) {
          return baz(x);
        }

        template&lt;typename T&gt; T baz(T x) {
          return x + 1;
        }

        export int foo();
      </code></pre>
      <p>Module implementation unit:</p>
      <pre><code data-trim lang="c++">
        // simple_lib_impl.cppm
        module simple_lib;
        int foo() {
          return bar(42);
        }
      </code></pre>
    </section>


    <section>
      <h2>Экспорт и импорт</h2>
      <div class=twocolumn>
        <div>
          <pre><code data-trim lang="c++">
            // module1.cppm
            export module Module1;
            struct S { int x; };
            export namespace N {
              S foo();
            }
            export S bar();
          </code></pre>
        </div>
        <div>
          <pre><code data-trim lang="c++">
            // module2.cppm
            export module Module2;
            export import Module1;

            export void baz() {
              bar();
            }
          </code></pre>
        </div>
      </div>
      <pre><code data-trim lang="c++">
        // main.cpp
        import Module2;
        int main() {
          baz(); // ok
          N::foo(); // ok
          auto s1 = bar(); // ok
          s.x; // ok;
          S s2; // error
        }
      </code></pre>
    </section>

    <section>
      <h2>Существующая модель компиляции</h2>
      <img class="plain" src="./header-compilation.png" alt="">
      <ul>
        <li>Хедера включаются в TU препроцессором</li>
        <li>Для хедеров нет отдельных правил и артифактов в системе сборки</li>
      </ul>
    </section>

    <section>
      <h2>Модель компиляции с модулями</h2>
      <img class="plain" src="./module-compilation.png" alt="">
      <ul>
        <li>cppm: исходны код Module Translation Unit</li>
        <li>BMI: Binary Module Interface</li>
        <li>Каждый модуль компилируется отдельно в BMI и (возможно) объектный файл</li>
      </ul>
    </section>

    <section class="center">
      <h1>Распространение модульного кода</h1>
      <h2>BMI - не артефакты для распространения!</h2>
    </section>

    <section>
      <h2>BMI - не артефакты для распространения!</h2>
      <ul>
        <li>BMI зависит от компилятора</li>
        <li>BMI зависит от флагов компилятора</li>
        <li>Распространяться должен исходный код интерфейса модуля </li>
        <li>
          BMIs можно распространять в особых ситуациях
          <ul>
            <li>Стандартная библиотека вместе с тулчейном (Visual C++, Xcode)</li>
            <li>BMI для фиксированного окружения внутри компании</li>
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>Распространение модульного кода</h2>
      <ul>
        <li>Исходный код - для module interface units</li>
        <li>Скомпилированные бинарники - для библиотек (скомпилированы из implementation units)</li>
        <li>Модули не помогают (и не мешают) проблеме пакетных менеджеров!</li>
      </ul>
    </section>


    <section>
      <h2>Linkage</h2>
      <p>Контролирует локальность символа</p>
      <ul>
        <li>External linkage</li>
        <li>Internal linkage (static, unnamed namespace)</li>
        <li>No linkage (type aliases, ...)</li>
      </ul>

      <p>Что делать с символами из модулей?</p>
    </section>

    <section>
      <h2>Module linkage</h2>
      <p>Символ виден внутри модуля</p>
      <ul>
        <li>External linkage (exported symbols)</li>
        <li>Module linkage (not exported symbols)</li>
        <li>Internal linkage (as before)</li>
        <li>No linkage (as before)</li>
      </ul>
      <p>Module identity is mangled into symbol name</p>
    </section>

    <section>
      <h2>Модули и препроцессор</h2>
      <ul>
        <li>Существующие макросы не влияют на компиляцию модуля</li>
        <li>
          Макросы из модуля не экспортируются
          <ul>
            <li>См. далее про исключение</li>
          </ul>
        </li>
      </ul>

      <pre><code data-trim lang="c++">
            // M.cppm
            export module M;
            #ifdef A
              #define B
            #endif
            // A и B не определены
          </code></pre>

      <pre><code data-trim lang="c++">
          // main.cpp
          #define A
          import M;

          // B не определен
        </code></pre>
    </section>

    <section>
      <h2>Переходный путь</h2>
      <ul>
        <li>Включить существующий header в модуль - скорее всего, некорректно</li>
        <li>Переписать весь код на модули - нереалистично</li>
      </ul>
    </section>

    <section>
      <h2>Header units</h2>
      <ul>
        <li>Пометить "хорошие" хедеры как модули</li>
        <li>Не требует изменений исходного кода</li>
        <li>Все символы экспортируются</li>
      </ul>
      <pre><code data-trim lang="c++">
        import normal.module;
        import &le;vector&ge;
      </code></pre>
      Все хедера стандартной библиотеки - "хорошие"
    </section>

    <section>
      <h2>Global module fragment</h2>
      <pre><code data-trim lang="c++">
        module;
        #include &lt;windows.h&gt;
        export module WinStuff;
        export HRESULT DoStuff(HANDLE h);
        export using MessageBox;
      </code></pre>
      <ul>
        <li>Можно использовать любой хедер</li>
        <li>Ничего не экспортируется автоматически</li>
      </ul>
    </section>

    <section>
      <ul>
        <li>Header units: graduate modularization of existing codebase</li>
        <li>Global module fragment: use old header in new modular code</li>
      </ul>
    </section>

    <section class="center">
      <h1>How fast are modules?</h1>
    </section>

    <section>
      <h2>How fast are modules</h2>
      <ul>
        <li>Many people want modules just for build time improvements</li>
        <li>Workload for the compiler is aysmptotically reduced</li>
        <li>Build parallelism is reduced</li>
      </ul>
    </section>

    <section>
      <h2>Build parallelism</h2>
      <ul>
        <li>Pre-scanning is not parallel</li>
        <li>Build DAG can have points of contention</li>
        <li>Transferring BMIs across distributed builds is not free</li>
      </ul>
    </section>

    <section>
      <h2>What build time improvements should we expect?</h2>
      <ul>
        <li>For clean builds</li>
        <li>On real-world projects</li>
        <li>On real-world hardware</li>
        <li>For common case</li>
      </ul>
    </section>

    <section>
      <h2>What build time improvements should we expect?</h2>
      <h3>50%-300% build time reduction</h3>
      <p>Based on:</p>
      <ul>
        <li>Existing implementations</li>
        <li>Experiments</li>
        <li>Speculation</li>
      </ul>
    </section>

    <section>
      <h2>Bad for modular builds:</h2>
      <ul>
        <li>Small, simple headers</li>
        <li>Little extra declarations in headers</li>
        <li>Heavy template-based metaprogramming</li>
        <li>A lot of header-only libraries with a single TU</li>
      </ul>
      <p></p>
      <h2>Good for modular builds:</h2>
      <ul>
        <li>Big headers, a lot of inline code</li>
        <li>A lot of extra declarations in headers</li>
        <li>Constexpr-based metaprogramming</li>
      </ul>
    </section>


    <section>
      <h2>Build time: opportunities</h2>
      <ul>
        <li>Incremental compilation might be faster: less stuff invalidated with interface changes</li>
        <li>Edit-and-compile cycle might be faster: imported modules could be built in parallel</li>
      </ul>
    </section>

    <section class="center">
      <h1>Tooling story</h1>
    </section>

    <section>
      <h2>Build system complications</h2>
      <ul>
        <li>Where to look for modules?</li>
        <li>What to compile first?</li>
      </ul>
    </section>

    <section>
      <h2>Where to look for modules?</h2>
      <p>Module name is spelled inside module unit:</p>
      <ul>
        <li>Not related to module source file name</li>
        <li>Not related to BMI name</li>
      </ul>
      <h3>Solutions</h3>
      <ul>
        <li>Pass explicit mapping to the compiler</li>
        <li>Filename-based lookup</li>
        <li>Discovery server</li>
      </ul>
    </section>

    <section>
      <h2>What module to compile first?</h2>
      <div class=twocolumn>
        <div>
          <pre><code data-trim lang="c++">
            export module A;

            import B;
          </code></pre>
          <pre><code data-trim lang="c++">
            export module B;
          </code></pre>
        </div>
        <div>
          <pre><code data-trim lang="c++">
            export module A;
          </code></pre>
          <pre><code data-trim lang="c++">
            export module B;

            import A;
          </code></pre>
        </div>
      </div>
      <h3>Solutions</h3>
      <ul>
        <li>Manually specify dependencies in the build script</li>
        <li>Pre-scan sources</li>
        <li>Build BMIs on the fly</li>
      </ul>
    </section>


    <section>
      <h2>Module preamble</h2>
      <p>Import declarations should be placed in the beginning.</p>
      <ul>
        <li>Still affected by preprocessor</li>
        <li>Need to figure out where it ends</li>
        <li>Not applicable for header units</li>
      </ul>
    </section>

    <section>
      <h2>Analyzers and IDEs</h2>
      <p>Headers cause troubles</p>
      <ul>
        <li>In what context to analyze?</li>
        <li>What to do with non-self-contained?</li>
        <li>What to do with diagnostics from headers</li>
        <li>A lot of existing IDEs use modular-like optimizations for performance reasons</li>
      </ul>
      <p>Modules solve most of this, but might require deeper integration with compiler and build systems</p>
    </section>

    <section>
      <h2>Current state of implementations</h2>
      <ul>
        <li>
          clang: ongoing development, experimental support available (-fmodules-ts)
          <ul>
            <li>Note: "Clang modules" (-fmodules) are NOT C++20 modules!
          </ul>
        </li>
        <li>Visual C++: experimental support available</li>
        <li>GCC: ongoing development in a branch</li>
        <li>Modularized STL is not planned for C++20, some implementation exist</li>
      </ul>
    </section>

    <section>
      <h2>Current state of build system support</h2>
      <ul>
        <li>build2 pioneered the effort</li>
        <li>CMake: work in progress</li>
        <li>Ninja: a patch has landed recently to make it possible</li>
        <li>Complicated with Make (unless explicitly specifying dependencies)</li>
      </ul>
    </section>

    <section>
      <h2>Summary</h2>
      <ul>
        <li>Modules are accepted in C++20</li>
        <li>More hygienic code reuse model</li>
        <li>Build time improvements (maybe not that large)</li>
        <li>Implementation and tooling are being worked on, but not there yet</li>
      </ul>
    </section>

    <section>
      <h1>Thank you!</h1>
      <h2>Questions?</h2>
    </section>

  </div>
</div>

<script src="js/reveal.js"></script>

<script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {src: 'plugin/highlight/highlight.js', async: false}
        ],

        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        center: true,

        transition: 'none',
    });
</script>
</body>
</html>
