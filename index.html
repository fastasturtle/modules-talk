<!doctype html>
<!--suppress HtmlRequiredLangAttribute -->
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="custom.css">
  <link rel="stylesheet" href="css/theme/white.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName('head')[0].appendChild(link);
  </script>
</head>
<body>
<div class="reveal">
  <div class="slides">
    <section>
      <h1>Модули в C++20</h1>
      <p>Дмитрий Кожевников</p>
      <img src="./jetbrains_copy.png" class="plain" alt="" width="781" height="247">
    </section>

    <section>
      <h2>Модули в C++20</h2>

      <ul>
        <li>Самая ожидаемая фича</li>
        <li>Самая непонятая фича</li>
        <li>Самая революционная фича</li>
        <li>Не добавляет новых возможностей для прикладного кода</li>
      </ul>
    </section>

    <section class="center">
      <h1>Зачем нужны модули?</h1>
    </section>

    <section>
      <h2>Существующая модель компиляции</h2>

      <ul>
        <li>Пришла из C</li>
        <li>Использует препроцессор для переиспользования кода</li>
        <li>Препроцессор не знает о семантике языка</li>
      </ul>
    </section>

    <section>
      <h2>Проблема: скорость компиляции</h2>
      <pre><code data-trim lang="c++">
        #include &lt;iostream&gt;
        int main() {
            std::cout << "Hello, world!" << std::endl;
            return 0;
        }
      </code></pre>

      <ul>
        <li>30 тысяч строчек (на моей машине)</li>
        <li>Все 30 тысяч должны быть обработаны компилятором</li>
        <li>Бывает миллион сточек в больших проектах</li>
        <li>Время сборки растет нелинейно с ростом проекта:
          <ul>
            <li>Увеличивается количество TU</li>
            <li>Увеличиваетя размер TU</li>
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>Проблема: протекающие имена</h2>
      <p>Пример кода из реализации stdlib:</p>
      <pre><code data-trim lang="c++">
      template &lt;class _Tp, class _Allocator&gt;
      inline _LIBCPP_INLINE_VISIBILITY void
      vector&lt;_Tp, _Allocator&gt;::push_back(const_reference __x)
      {
          if (this->__end_ != this->__end_cap())
          {
              __RAII_IncreaseAnnotator __annotator(*this);
              __alloc_traits::construct(this->__alloc(),
                                        _VSTD::__to_raw_pointer(this->__end_), __x);
              __annotator.__done();
              ++this->__end_;
          }
          else
              __push_back_slow_path(__x);
      }
      </code></pre>
    </section>

    <section>
      <h2>Проблема: протекающие имена</h2>
      <p>Почему это так ужасно?</p>
      <pre><code data-trim lang="c++">
        //user-header.h
        #define annotator 1
        class RAII_IncreaseAnnotator{};
      </code></pre>
      <pre><code data-trim lang="c++">
        #include "user-header.h"
        #include &lt;vector&gt;
      </code></pre>
    </section>

    <section>
      <h2>Проблема: протекающие имена</h2>
      <ul>
        <li>
          Все имена из ранее включенных хедеров - в зоне видимости
          <ul>
            <li>Макросы</li>
            <li>Классы</li>
            <li>Глобальные переменные</li>
          </ul>
        </li>
        <li>Особенно плохо для авторов библиотек</li>
        <li>Авторы стандартной библиотеки могу использовать зарезервированные имена</li>
      </ul>
    </section>

    <section>
      <h2>Проблема: нарушение ODR</h2>
      <p>One Definition Rule (упрощенно):</p>
      <ul>
        <li>Только одно определение в TU</li>
        <li>Все определения в "программе" должны быть идентичными</li>
        <li>При нарушении: ill-formed, no diagnostics required</li>
      </ul>
    </section>

    <section>
      <h2>Проблема: нарушение ODR</h2>
      <pre><code data-trim lang="c++">
        // a.cpp
        #include "header.h"
      </code></pre>
      <pre><code data-trim lang="c++">
        // b.cpp
        #define _NDEBUG
        #include "header.h"
      </code></pre>

      <ul>
        <li>Влияет на member layout, размер объектов, типы, ...</li>
        <li>Легко ошибиться случайно</li>
      </ul>
    </section>

    <section>
      <h2>Проблема: случайные зависимости</h2>
      <pre><code data-trim lang="c++">
        // lib1.h
        struct Lib1Widget{};
      </code></pre>
      <pre><code data-trim lang="c++">
        // lib2.h
        struct Lib2Gadget{
           Lib2Gadget(Lib1Widget const& w);
        };
      </code></pre>
      <pre><code data-trim lang="c++">
        // main.cpp
        #include "lib1.h"
        #include "lib2.h"
      </code></pre>

    </section>

    <section>
      <h2>Модули призваны улучшить:</h2>
      <ul>
        <li>Время сборки</li>
        <li>Изоляцию имен</li>
        <li>Борьбу с ODR</li>
        <li>Отслеживание зависимостей</li>
      </ul>
    </section>

    <section>
      <h2>Модули: Hello, world!</h2>
      <pre><code data-trim lang="c++">
        import std.io;
        int main() {
           std::cout << "Hello, world!" << std::endl;
        }
      </code></pre>
      <ul>
        <li>Модуль std.io парсится отдельно</li>
        <li>Интерфейс модуля после парсинга хранится в бинарном файле</li>
        <li>Import declarations загружают интерфейс модуля без репарса</li>
      </ul>
    </section>

    <section>
      <h2>Модули: Hello, world!</h2>
      <pre><code data-trim lang="c++">
        import std.io;
        int main() {
           std::cout << "Hello, world!" << std::endl;
        }
      </code></pre>
      <ul>
        <li>Точки в имени модуля ничего не значат</li>
        <li>Модули не связаны с namespaces</li>
        <li>
          Информация в модуле эквивалентна исходному коду:
          <ul>
            <li>Inline функции</li>
            <li>Шаблоны</li>
            <li>Сообщения об ошибках</li>
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>Информация в модуле эквивалентна коду:</h2>
      <ul>
        <li>Inline функции</li>
        <li>Шаблоны</li>
        <li>Сообщения об ошибках</li>
      </ul>
    </section>

    <section>
      <h2>Библиотека: header-based</h2>
      <pre><code data-trim lang="c++">
        // simple_lib.h
        int foo();
        template&lt;typename T&gt; T bar(T x) {
          return detail::baz(x);
        }

        namespace detail {
          template&lt;typename T&gt; T baz(T x) {
            return x + 1;
          }
        }
      </code></pre>
      <pre><code data-trim lang="c++">
        // simple_lib.cpp
        #include "header.h"
        int foo() {
          return bar(42);
        }
      </code></pre>
    </section>

    <section>
      <h2>Библиотека: на модулях</h2>
      <pre><code data-trim lang="c++">
        // simple_lib.cppm
        export module simple_lib;

        template&lt;typename T&gt;
        export T bar(T x) {
          return baz(x);
        }
        
        template&lt;typename T&gt; T baz(T x) {
          return x + 1;
        }

        export int foo() {
          return bar(42);
        }
      </code></pre>
    </section>

    <section>
      <h2>Module units</h2>
      <p>Module interface unit:</p>
      <pre><code data-trim lang="c++">
        // simple_lib.cppm
        export module simple_lib;

        template&lt;typename T&gt;
        export T bar(T x) {
          return baz(x);
        }

        template&lt;typename T&gt; T baz(T x) {
          return x + 1;
        }

        export int foo();
      </code></pre>
      <p>Module implementation unit:</p>
      <pre><code data-trim lang="c++">
        // simple_lib_impl.cppm
        module simple_lib;
        int foo() {
          return bar(42);
        }
      </code></pre>
    </section>


    <section>
      <h2>Экспорт и импорт</h2>
      <div class=twocolumn>
        <div>
          <pre><code data-trim lang="c++">
            // module1.cppm
            export module Module1;
            struct S { int x; };
            export namespace N {
              S foo();
            }
            export S bar();
          </code></pre>
        </div>
        <div>
          <pre><code data-trim lang="c++">
            // module2.cppm
            export module Module2;
            export import Module1;

            export void baz() {
              bar();
            }
          </code></pre>
        </div>
      </div>
      <pre><code data-trim lang="c++">
        // main.cpp
        import Module2;
        int main() {
          baz(); // ok
          N::foo(); // ok
          auto s1 = bar(); // ok
          s1.x; // ok;
          S s2; // error
        }
      </code></pre>
    </section>

    <section>
      <h2>Существующая модель компиляции</h2>
      <img class="plain" src="./header-compilation.png" alt="">
      <ul>
        <li>Хедера включаются в TU препроцессором</li>
        <li>Для хедеров нет отдельных правил и артефактов в системе сборки</li>
      </ul>
    </section>

    <section>
      <h2>Модель компиляции с модулями</h2>
      <img class="plain" src="./module-compilation-small.png" height="273" width="386" alt="">
      <ul>
        <li>cppm: исходны код Module Translation Unit</li>
        <li>BMI: Binary Module Interface</li>
        <li>Каждый модуль компилируется отдельно в BMI и (возможно) объектный файл</li>
      </ul>
    </section>

    <section class="center">
      <h2>BMI - не артефакты для распространения!</h2>
    </section>

    <section>
      <h2>BMI - не артефакты для распространения!</h2>
      <ul>
        <li>BMI зависит от компилятора</li>
        <li>BMI зависит от флагов компилятора</li>
        <li>Распространяться должен исходный код интерфейса модуля </li>
        <li>
          BMIs можно распространять в особых ситуациях
          <ul>
            <li>Стандартная библиотека вместе с тулчейном (Visual C++, Xcode)</li>
            <li>BMI для фиксированного окружения внутри компании</li>
          </ul>
        </li>
      </ul>
    </section>

    <section>
      <h2>Распространение модульного кода</h2>
      <ul>
        <li>Исходный код — для module interface units</li>
        <li>Скомпилированные бинарники — для библиотек (скомпилированы из implementation units)</li>
        <li>Модули не помогают (и не мешают) проблеме пакетных менеджеров!</li>
      </ul>
    </section>


    <section>
      <h2>Linkage</h2>
      <p>Контролирует локальность символа</p>
      <ul>
        <li>External linkage</li>
        <li>Internal linkage (static, unnamed namespace)</li>
        <li>No linkage (type aliases, ...)</li>
      </ul>

      <p>Что делать с символами из модулей?</p>
    </section>

    <section>
      <h2>Module linkage</h2>
      <p>Символ виден внутри модуля</p>
      <ul>
        <li>External linkage (exported symbols)</li>
        <li>Module linkage (not exported symbols)</li>
        <li>Internal linkage (as before)</li>
        <li>No linkage (as before)</li>
      </ul>
      <p>На практике достигается новыми правилами манглинга</p>
    </section>

    <section>
      <h2>Модули и препроцессор</h2>
      <ul>
        <li>Существующие макросы не влияют на компиляцию модуля</li>
        <li>
          Макросы из модуля не экспортируются
          <ul>
            <li>См. далее про исключение</li>
          </ul>
        </li>
      </ul>

      <pre><code data-trim lang="c++">
            // M.cppm
            export module M;
            #ifdef A
              #define B
            #endif
            // A и B не определены
          </code></pre>

      <pre><code data-trim lang="c++">
          // main.cpp
          #define A
          import M;

          // B не определен
        </code></pre>
    </section>

    <section>
      <h2>Переходный путь</h2>
      <ul>
        <li>Включить существующий header в модуль - скорее всего, некорректно</li>
        <li>Переписать весь код на модули - нереалистично</li>
      </ul>
    </section>

    <section>
      <h2>Header units</h2>
      <ul>
        <li>Пометить "хорошие" хедеры как модули</li>
        <li>Не требует изменений исходного кода</li>
        <li>Все символы экспортируются</li>
        <li>Макросы видны после импорта!</li>
      </ul>
      <pre><code data-trim lang="c++">
        import normal.module;
        import &le;vector&ge;
      </code></pre>
      Все хедера стандартной библиотеки - "хорошие"
    </section>

    <section>
      <h2>Global module fragment</h2>
      <pre><code data-trim lang="c++">
        module;
        #include &lt;windows.h&gt;
        export module WinStuff;
        export HRESULT DoStuff(HANDLE h);
        export using MessageBox; // MessageBoxW =)
      </code></pre>
      <ul>
        <li>Можно использовать любой хедер</li>
        <li>Ничего не экспортируется автоматически</li>
      </ul>
    </section>

    <section>
      <ul>
        <li>Header units: постепенная модуляризация существующей кодовой базы</li>
        <li>Global module fragment: новая модульная кодовая база с использованием старых хедеров</li>
      </ul>
    </section>

    <section class="center">
      <h1>Что с временем компиляции?</h1>
    </section>

    <section>
      <h2>Что со временем компиляции?</h2>
      <ul>
        <li>Многие ждут модули исключительно ради ускорения билдов</li>
        <li>Количество работы для компилятора уменьшается</li>
        <li>Параллельность билда ухудщается</li>
      </ul>
    </section>

    <section>
      <h2>Параллельность билдов</h2>
      <ul>
        <li>Нужно анализировать текст модулей для определения зависимостей</li>
        <li>Анализ не параллелится</li>
        <li>Копирование BMI в распределенных билдах не бесплатное</li>
      </ul>
    </section>

    <section>
      <h2>Каких улучшений ожидать?</h2>
      <h3>50%-1000% уменьшение времени билда</h3>
      <p>На основе:</p>
      <ul>
        <li>Существующих реализаций</li>
        <li>Экспериментов</li>
        <li>Спекуляций</li>
      </ul>
    </section>

    <section>
      <h2>Плохо работают в модульных билдах:</h2>
      <ul>
        <li>Небольшие простые хедера</li>
        <li>Много шаблонного метапрограммирования</li>
      </ul>
      <p></p>
      <h2>Хорошо работают в модульных билдах:</h2>
      <ul>
        <li>Большие хедера, много inline кода</li>
        <li>Много метапрограммирования на constexpr</li>
      </ul>
    </section>


    <section>
      <h2>Новые возможности для билдов:</h2>
      <ul>
        <li>Ускорение инкрементальной компиляции</li>
        <li>Параллелизм сборки одного TU</li>
      </ul>
    </section>

    <section class="center">
      <h1>Тулинг</h1>
    </section>

    <section>
      <h2>Сложности для систем сборки</h2>
      <ul>
        <li>Где искать модули?</li>
        <li>В каком порядке их компилировать?</li>
      </ul>
    </section>

    <section>
      <h2>Где искать модули?</h2>
      <p>Имя модуля написано в исходном коде:</p>
      <ul>
        <li>Не связано с именем файла с кодом</li>
        <li>Не связано с именем файла с BMI</li>
      </ul>
    </section>

    <section>
      <h2>Где искать модули?</h2>
      <h3>Решения:</h3>
      <ul>
        <li>Договориться про стандартную схему именования (ха-ха)</li>
        <li>Явно передавать информацию компилятору</li>
        <li>Огранизовать общение компилятора и системы сборки</li>
      </ul>
    </section>

    <section>
      <h2>В каком порядке компилировать модули?</h2>
      <div class=twocolumn>
        <div>
          <pre><code data-trim lang="c++">
            export module A;

            import B;
          </code></pre>
          <pre><code data-trim lang="c++">
            export module B;
          </code></pre>
        </div>
        <div>
          <pre><code data-trim lang="c++">
            export module A;
          </code></pre>
          <pre><code data-trim lang="c++">
            export module B;

            import A;
          </code></pre>
        </div>
      </div>
      <h3>Решения</h3>
      <ul>
        <li>Вручную указывать зависимости</li>
        <li>Анализировать код перед билдом</li>
        <li>Строить BMI на лету</li>
      </ul>
    </section>


<!--    <section>-->
<!--      <h2>Module preamble</h2>-->
<!--      <p>Import declarations should be placed in the beginning.</p>-->
<!--      <ul>-->
<!--        <li>Still affected by preprocessor</li>-->
<!--        <li>Need to figure out where it ends</li>-->
<!--        <li>Not applicable for header units</li>-->
<!--      </ul>-->
<!--    </section>-->

    <section>
      <h2>IDE и статические анализаторы</h2>
      <p>Есть проблемы с хедерами</p>
      <ul>
        <li>В каком контексте анализировать хедера?</li>
        <li>Что, если они не самодостаточные?</li>
        <li>Что делать с диагностиками из чужих хедеров?</li>
        <li>Существующие IDE используют техники оптимизаций, похожие на модули</li>
      </ul>
      <p>Модули помогают с этим, но могут потребовать более тесной интеграции с компиляторами и системами сборки</p>
    </section>

    <section>
      <h2>Текущий статус поддержки компиляторами</h2>
      <ul>
        <li>
          clang: -fmodules-ts
          <ul>
            <li>-fmodules это НЕ C++20 модули!
          </ul>
        </li>
        <li>Visual C++: /experimental:module</li>
        <li>GCC: cxx-modules бранч</li>
      </ul>
    </section>

    <section>
      <h2>Стандартная библиотека</h2>
      <ul>
        <li>С++23</li>
        <li>Доступны реализации от некоторых вендоров</li>
        <li>Header Units в C++20</li>
      </ul>
    </section>

    <section>
      <h2>Текущий статус поддержки системами сборки</h2>
      <ul>
        <li>build2 провел первые эксперименты</li>
        <li>CMake: активная работа в процессе</li>
        <li>Сложности с Make-based системами (если не задавать зависимости явно)</li>
      </ul>
    </section>

    <section>
      <h2>Резюме</h2>
      <ul>
        <li>Модули приняты в C++20</li>
        <li>Более аккуратный способ переиспользовать код</li>
        <li>Ускорение сборки (но не такое большое, как некоторые надеялись)</li>
        <li>Авторы компиляторов и тулинга в процессе поддержки</li>
      </ul>
    </section>

    <section>
      <h1>Спасибо за внимание!</h1>
      <h2>Вопросы?</h2>
    </section>

  </div>
</div>

<script src="js/reveal.js"></script>

<script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {src: 'plugin/highlight/highlight.js', async: false}
        ],

        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        center: true,

        transition: 'none',
    });
</script>
</body>
</html>
